# generated by datamodel-codegen:
#   filename:  compose-spec.json
#   timestamp: 2025-08-10T01:49:12+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel


class Cgroup(Enum):
    host = "host"
    private = "private"


class CpuCount(RootModel[int]):
    root: int = Field(..., description="Number of usable CPUs.", ge=0)


class CpuPercent(RootModel[int]):
    root: int = Field(..., description="Percentage of CPU resources to use.", ge=0, le=100)


class CredentialSpec(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    config: Optional[str] = Field(None, description="The name of the credential spec Config to use.")
    file: Optional[str] = Field(None, description="Path to a credential spec file.")
    registry: Optional[str] = Field(None, description="Path to a credential spec in the Windows registry.")


class Condition(Enum):
    service_started = "service_started"
    service_healthy = "service_healthy"
    service_completed_successfully = "service_completed_successfully"


class DependsOn(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    restart: Optional[Union[bool, str]] = Field(
        None,
        description="Whether to restart dependent services when this service is restarted.",
    )
    required: Optional[bool] = Field(
        True,
        description="Whether the dependency is required for the dependent service to start.",
    )
    condition: Condition = Field(
        ...,
        description="Condition to wait for. 'service_started' waits until the service has started, 'service_healthy' waits until the service is healthy (as defined by its healthcheck), 'service_completed_successfully' waits until the service has completed successfully.",
    )


class Devices(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    source: str = Field(..., description="Path on the host to the device.")
    target: Optional[str] = Field(None, description="Path in the container where the device will be mapped.")
    permissions: Optional[str] = Field(None, description="Cgroup permissions for the device (rwm).")


class Extends(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    service: str = Field(..., description="The name of the service to extend.")
    file: Optional[str] = Field(None, description="The file path where the service to extend is defined.")


class Provider(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: str = Field(
        ...,
        description="ExternalVolumeNetwork component used by Compose to manage setup and teardown lifecycle of the service.",
    )
    options: Optional[Dict[str, Union[Union[str, float, bool], List[Union[str, float, bool]]]]] = Field(None, description="Provider-specific options.")


class Logging(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    driver: Optional[str] = Field(
        None,
        description="Logging driver to use, such as 'json-file', 'syslog', 'journald', etc.",
    )
    options: Optional[Dict[str, Optional[Union[str, float]]]] = Field(None, description="Options for the logging driver.")


class Models(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    endpoint_var: Optional[str] = Field(None, description="Environment variable set to AI model endpoint.")
    model_var: Optional[str] = Field(None, description="Environment variable set to AI model name.")


class OomScoreAdj(RootModel[int]):
    root: int = Field(
        ...,
        description="Tune host's OOM preferences for the container (accepts -1000 to 1000).",
        ge=-1000,
        le=1000,
    )


class Ports(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Optional[str] = Field(None, description="A human-readable name for this port mapping.")
    mode: Optional[str] = Field(
        None,
        description="The port binding mode, either 'host' for publishing a host port or 'ingress' for load balancing.",
    )
    host_ip: Optional[str] = Field(None, description="The host IP to bind to.")
    target: Optional[Union[int, str]] = Field(None, description="The port inside the container.")
    published: Optional[Union[str, int]] = Field(None, description="The publicly exposed port.")
    protocol: Optional[str] = Field(None, description="The port protocol (tcp or udp).")
    app_protocol: Optional[str] = Field(
        None,
        description="Application protocol to use with the port (e.g., http, https, mysql).",
    )


class Type(Enum):
    bind = "bind"
    volume = "volume"
    tmpfs = "tmpfs"
    cluster = "cluster"
    npipe = "npipe"
    image = "image"


class Recursive(Enum):
    enabled = "enabled"
    disabled = "disabled"
    writable = "writable"
    readonly = "readonly"


class Selinux(Enum):
    z = "z"
    Z = "Z"


class Bind(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    propagation: Optional[str] = Field(
        None,
        description="The propagation mode for the bind mount: 'shared', 'slave', 'private', 'rshared', 'rslave', or 'rprivate'.",
    )
    create_host_path: Optional[Union[bool, str]] = Field(None, description="Create the host path if it doesn't exist.")
    recursive: Optional[Recursive] = Field(None, description="Recursively mount the source directory.")
    selinux: Optional[Selinux] = Field(
        None,
        description="SELinux relabeling options: 'z' for shared content, 'Z' for private unshared content.",
    )


class Size(RootModel[int]):
    root: int = Field(..., description="Size of the tmpfs mount in bytes.", ge=0)


class Tmpfs(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    size: Optional[Union[Size, str]] = Field(None, description="Size of the tmpfs mount in bytes.")
    mode: Optional[Union[float, str]] = Field(None, description="File mode of the tmpfs in octal.")


class Image(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    subpath: Optional[str] = Field(None, description="Path within the image to mount instead of the image root.")


class Healthcheck(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    disable: Optional[Union[bool, str]] = Field(
        None,
        description="Disable any container-specified healthcheck. Set to true to disable.",
    )
    interval: Optional[str] = Field(
        None,
        description="Time between running the check (e.g., '1s', '1m30s'). Default: 30s.",
    )
    retries: Optional[Union[float, str]] = Field(
        None,
        description="Number of consecutive failures needed to consider the container as unhealthy. Default: 3.",
    )
    test: Optional[Union[str, List[str]]] = Field(
        None,
        description="The test to perform to check container health. Can be a string or a list. The first item is either NONE, CMD, or CMD-SHELL. If it's CMD, the rest of the command is exec'd. If it's CMD-SHELL, the rest is run in the shell.",
    )
    timeout: Optional[str] = Field(
        None,
        description="Maximum time to allow one check to run (e.g., '1s', '1m30s'). Default: 30s.",
    )
    start_period: Optional[str] = Field(
        None,
        description="Start period for the container to initialize before starting health-retries countdown (e.g., '1s', '1m30s'). Default: 0s.",
    )
    start_interval: Optional[str] = Field(
        None,
        description="Time between running the check during the start period (e.g., '1s', '1m30s'). Default: interval value.",
    )


class Action(Enum):
    rebuild = "rebuild"
    sync = "sync"
    restart = "restart"
    sync_restart = "sync+restart"
    sync_exec = "sync+exec"


class Order(Enum):
    start_first = "start-first"
    stop_first = "stop-first"


class RollbackConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    parallelism: Optional[Union[int, str]] = Field(
        None,
        description="The number of containers to rollback at a time. If set to 0, all containers rollback simultaneously.",
    )
    delay: Optional[str] = Field(
        None,
        description="The time to wait between each container group's rollback (e.g., '1s', '1m30s').",
    )
    failure_action: Optional[str] = Field(None, description="Action to take if a rollback fails: 'continue', 'pause'.")
    monitor: Optional[str] = Field(
        None,
        description="Duration to monitor each task for failures after it is created (e.g., '1s', '1m30s').",
    )
    max_failure_ratio: Optional[Union[float, str]] = Field(None, description="Failure rate to tolerate during a rollback.")
    order: Optional[Order] = Field(
        None,
        description="Order of operations during rollbacks: 'stop-first' (default) or 'start-first'.",
    )


class UpdateConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    parallelism: Optional[Union[int, str]] = Field(None, description="The number of containers to update at a time.")
    delay: Optional[str] = Field(
        None,
        description="The time to wait between updating a group of containers (e.g., '1s', '1m30s').",
    )
    failure_action: Optional[str] = Field(
        None,
        description="Action to take if an update fails: 'continue', 'pause', 'rollback'.",
    )
    monitor: Optional[str] = Field(
        None,
        description="Duration to monitor each updated task for failures after it is created (e.g., '1s', '1m30s').",
    )
    max_failure_ratio: Optional[Union[float, str]] = Field(None, description="Failure rate to tolerate during an update (0 to 1).")
    order: Optional[Order] = Field(
        None,
        description="Order of operations during updates: 'stop-first' (default) or 'start-first'.",
    )


class Limits(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    cpus: Optional[Union[float, str]] = Field(
        None,
        description="Limit for how much of the available CPU resources, as number of cores, a container can use.",
    )
    memory: Optional[str] = Field(
        None,
        description="Limit on the amount of memory a container can allocate (e.g., '1g', '1024m').",
    )
    pids: Optional[Union[int, str]] = Field(None, description="Maximum number of PIDs available to the container.")


class RestartPolicy(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    condition: Optional[str] = Field(
        None,
        description="Condition for restarting the container: 'none', 'on-failure', 'any'.",
    )
    delay: Optional[str] = Field(None, description="Delay between restart attempts (e.g., '1s', '1m30s').")
    max_attempts: Optional[Union[int, str]] = Field(None, description="Maximum number of restart attempts before giving up.")
    window: Optional[str] = Field(
        None,
        description="Time window used to evaluate the restart policy (e.g., '1s', '1m30s').",
    )


class Preference(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    spread: Optional[str] = Field(
        None,
        description="Spread tasks evenly across values of the specified node label.",
    )


class Placement(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    constraints: Optional[List[str]] = Field(
        None,
        description="Placement constraints for the service (e.g., 'node.role==manager').",
    )
    preferences: Optional[List[Preference]] = Field(None, description="Placement preferences for the service.")
    max_replicas_per_node: Optional[Union[int, str]] = Field(None, description="Maximum number of replicas of the service.")


class DiscreteResourceSpec(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    kind: Optional[str] = Field(None, description="Type of resource (e.g., 'GPU', 'FPGA', 'SSD').")
    value: Optional[Union[float, str]] = Field(None, description="Number of resources of this kind to reserve.")


class GenericResource(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    discrete_resource_spec: Optional[DiscreteResourceSpec] = Field(None, description="Specification for discrete (countable) resources.")


class GenericResources(RootModel[List[GenericResource]]):
    root: List[GenericResource] = Field(
        ...,
        description="User-defined resources for services, allowing services to reserve specialized hardware resources.",
    )


class Gpus1(Enum):
    all = "all"


class ConfigItem(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    subnet: Optional[str] = Field(None, description="Subnet in CIDR format that represents a network segment.")
    ip_range: Optional[str] = Field(None, description="Range of IPs from which to allocate container IPs.")
    gateway: Optional[str] = Field(None, description="IPv4 or IPv6 gateway for the subnet.")
    aux_addresses: Optional[Dict[str, str]] = Field(None, description="Auxiliary IPv4 or IPv6 addresses used by Network driver.")


class Ipam(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    driver: Optional[str] = Field(None, description="Custom IPAM driver, instead of the default.")
    config: Optional[List[ConfigItem]] = Field(None, description="List of IPAM configuration blocks.")
    options: Optional[Dict[str, str]] = Field(None, description="Driver-specific options for the IPAM driver.")


class ExternalVolumeNetwork(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Optional[str] = Field(
        None,
        description="Specifies the name of the external network. Deprecated: use the 'name' property instead.",
    )


class External1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Optional[str] = Field(
        None,
        description="Specifies the name of the external volume. Deprecated: use the 'name' property instead.",
    )


class ExternalConfig(BaseModel):
    name: Optional[str] = Field(None, description="Specifies the name of the external secret.")


class External3(BaseModel):
    name: Optional[str] = Field(
        None,
        description="Specifies the name of the external config. Deprecated: use the 'name' property instead.",
    )


class Model(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Optional[str] = Field(None, description="Custom name for this model.")
    model: str = Field(..., description="Language Model to run.")
    context_size: Optional[int] = None
    runtime_flags: Optional[List[str]] = Field(None, description="Raw runtime flags to pass to the inference engine.")


class Command(RootModel[Optional[Union[str, List[str]]]]):
    root: Optional[Union[str, List[str]]] = Field(
        ...,
        description="Command to run in the container, which can be specified as a string (shell form) or array (exec form).",
    )


class EnvFilePath(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    path: str = Field(..., description="Path to the environment file.")
    format: Optional[str] = Field(
        None,
        description="Format attribute lets you to use an alternative file formats for env_file. When not set, env_file is parsed according to Compose rules.",
    )
    required: Optional[Union[bool, str]] = Field(
        True,
        description="Whether the file is required. If true and the file doesn't exist, an error will be raised.",
    )


class EnvFile(RootModel[Union[str, List[Union[str, EnvFilePath]]]]):
    root: Union[str, List[Union[str, EnvFilePath]]]


class LabelFile(RootModel[Union[str, List[str]]]):
    root: Union[str, List[str]]


class ListOfStrings(RootModel[List[str]]):
    root: List[str] = Field(..., description="A list of unique string values.")


class ListOrDict1(RootModel[List[Any]]):
    root: List[Any] = Field(..., description="A list of unique string values.")


class ListOrDict(RootModel[Union[Dict[str, Optional[Union[str, float, bool]]], ListOrDict1]]):
    root: Union[Dict[str, Optional[Union[str, float, bool]]], ListOrDict1] = Field(
        ...,
        description="Either a dictionary mapping keys to values, or a list of strings.",
    )


class ExtraHosts1(RootModel[List[Any]]):
    root: List[Any] = Field(..., description="List of IP addresses for the hostname.")


class ExtraHosts2(RootModel[List[Any]]):
    root: List[Any] = Field(..., description="List of host:IP mappings in the format 'hostname:IP'.")


class ExtraHosts(RootModel[Union[Dict[str, Union[str, ExtraHosts1]], ExtraHosts2]]):
    root: Union[Dict[str, Union[str, ExtraHosts1]], ExtraHosts2] = Field(
        ...,
        description="Additional hostnames to be defined in the container's /etc/hosts file.",
    )


class BlkioLimit(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    path: Optional[str] = Field(None, description="Path to the device (e.g., '/dev/sda').")
    rate: Optional[Union[int, str]] = Field(None, description="Rate limit in bytes per second or IO operations per second.")


class BlkioWeight(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    path: Optional[str] = Field(None, description="Path to the device (e.g., '/dev/sda').")
    weight: Optional[Union[int, str]] = Field(None, description="Relative weight for the device, between 10 and 1000.")


class ServiceConfigOrSecret1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    source: Optional[str] = Field(
        None,
        description="Name of the config or secret as defined in the top-level configs or secrets section.",
    )
    target: Optional[str] = Field(
        None,
        description="Path in the container where the config or secret will be mounted. Defaults to /<source> for configs and /run/secrets/<source> for secrets.",
    )
    uid: Optional[str] = Field(None, description="UID of the file in the container. Default is 0 (root).")
    gid: Optional[str] = Field(None, description="GID of the file in the container. Default is 0 (root).")
    mode: Optional[Union[float, str]] = Field(
        None,
        description="File permission mode inside the container, in octal. Default is 0444 for configs and 0400 for secrets.",
    )


class ServiceConfigOrSecret(RootModel[List[Union[str, ServiceConfigOrSecret1]]]):
    root: List[Union[str, ServiceConfigOrSecret1]] = Field(
        ...,
        description="Configuration for service configs or secrets, defining how they are mounted in the container.",
    )


class Ulimits1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    hard: Union[int, str] = Field(
        ...,
        description="Hard limit for the ulimit type. This is the maximum allowed value.",
    )
    soft: Union[int, str] = Field(
        ...,
        description="Soft limit for the ulimit type. This is the value that's actually enforced.",
    )


class Ulimits(RootModel[Dict[str, Union[Union[int, str], Ulimits1]]]):
    root: Dict[str, Union[Union[int, str], Ulimits1]] = Field(
        ...,
        description="Container ulimit options, controlling resource limits for processes inside the container.",
    )


class Build(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    context: Optional[str] = Field(None, description="Path to the build context. Can be a relative path or a URL.")
    dockerfile: Optional[str] = Field(None, description="Name of the Dockerfile to use for building the image.")
    dockerfile_inline: Optional[str] = Field(
        None,
        description="Inline Dockerfile content to use instead of a Dockerfile from the build context.",
    )
    entitlements: Optional[List[str]] = Field(
        None,
        description="List of extra privileged entitlements to grant to the build process.",
    )
    args: Optional[ListOrDict] = Field(
        None,
        description="Build-time variables, specified as a map or a list of KEY=VAL pairs.",
    )
    ssh: Optional[ListOrDict] = Field(
        None,
        description="SSH agent socket or keys to expose to the build. Format is either a string or a list of 'default|<id>[=<socket>|<key>[,<key>]]'.",
    )
    labels: Optional[ListOrDict] = Field(None, description="Labels to apply to the built image.")
    cache_from: Optional[List[str]] = Field(
        None,
        description="List of sources the image builder should use for cache resolution",
    )
    cache_to: Optional[List[str]] = Field(None, description="Cache destinations for the build cache.")
    no_cache: Optional[Union[bool, str]] = Field(None, description="Do not use cache when building the image.")
    additional_contexts: Optional[ListOrDict] = Field(
        None,
        description="Additional build contexts to use, specified as a map of name to context path or URL.",
    )
    network: Optional[str] = Field(
        None,
        description="Network mode to use for the build. Options include 'default', 'none', 'host', or a network name.",
    )
    pull: Optional[Union[bool, str]] = Field(None, description="Always attempt to pull a newer version of the image.")
    target: Optional[str] = Field(None, description="Build stage to target in a multi-stage Dockerfile.")
    shm_size: Optional[Union[int, str]] = Field(
        None,
        description="Size of /dev/shm for the build container. A string value can use suffix like '2g' for 2 gigabytes.",
    )
    extra_hosts: Optional[ExtraHosts] = Field(None, description="Add hostname mappings for the build container.")
    isolation: Optional[str] = Field(None, description="Container isolation technology to use for the build process.")
    privileged: Optional[Union[bool, str]] = Field(None, description="Give extended privileges to the build container.")
    secrets: Optional[ServiceConfigOrSecret] = Field(
        None,
        description="Secrets to expose to the build. These are accessible at build-time.",
    )
    tags: Optional[List[str]] = Field(None, description="Additional tags to apply to the built image.")
    ulimits: Optional[Ulimits] = Field(None, description="Override the default ulimits for the build container.")
    platforms: Optional[List[str]] = Field(
        None,
        description="Platforms to build for, e.g., 'linux/amd64', 'linux/arm64', or 'windows/amd64'.",
    )


class BlkioConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    device_read_bps: Optional[List[BlkioLimit]] = Field(None, description="Limit read rate (bytes per second) from a device.")
    device_read_iops: Optional[List[BlkioLimit]] = Field(None, description="Limit read rate (IO per second) from a device.")
    device_write_bps: Optional[List[BlkioLimit]] = Field(None, description="Limit write rate (bytes per second) to a device.")
    device_write_iops: Optional[List[BlkioLimit]] = Field(None, description="Limit write rate (IO per second) to a device.")
    weight: Optional[Union[int, str]] = Field(
        None,
        description="Block IO weight (relative weight) for the service, between 10 and 1000.",
    )
    weight_device: Optional[List[BlkioWeight]] = Field(None, description="Block IO weight (relative weight) for specific devices.")


class Networks(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    aliases: Optional[ListOfStrings] = Field(None, description="Alternative hostnames for this service on the network.")
    interface_name: Optional[str] = Field(None, description="Interface network name used to connect to network")
    ipv4_address: Optional[str] = Field(
        None,
        description="Specify a static IPv4 address for this service on this network.",
    )
    ipv6_address: Optional[str] = Field(
        None,
        description="Specify a static IPv6 address for this service on this network.",
    )
    link_local_ips: Optional[ListOfStrings] = Field(None, description="List of link-local IPs.")
    mac_address: Optional[str] = Field(None, description="Specify a MAC address for this service on this network.")
    driver_opts: Optional[Dict[str, Union[str, float]]] = Field(None, description="Driver options for this network.")
    priority: Optional[float] = Field(None, description="Specify the priority for the network connection.")
    gw_priority: Optional[float] = Field(None, description="Specify the gateway priority for the network connection.")


class AdditionalVolumeOption(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    labels: Optional[ListOrDict] = Field(None, description="Labels to apply to the volume.")
    nocopy: Optional[Union[bool, str]] = Field(
        None,
        description="Flag to disable copying of data from a container when a volume is created.",
    )
    subpath: Optional[str] = Field(None, description="Path within the volume to mount instead of the volume root.")


class Volumes(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Type = Field(
        ...,
        description="The mount type: bind for mounting host directories, volume for named volumes, tmpfs for temporary filesystems, cluster for cluster volumes, npipe for named pipes, or image for mounting from an image.",
    )
    source: Optional[str] = Field(
        None,
        description="The source of the mount, a path on the host for a bind mount, a docker image reference for an image mount, or the name of a volume defined in the top-level volumes key. Not applicable for a tmpfs mount.",
    )
    target: Optional[str] = Field(None, description="The path in the container where the volume is mounted.")
    read_only: Optional[Union[bool, str]] = Field(None, description="Flag to set the volume as read-only.")
    consistency: Optional[str] = Field(
        None,
        description="The consistency requirements for the mount. Available values are platform specific.",
    )
    bind: Optional[Bind] = Field(None, description="Configuration specific to bind mounts.")
    volume: Optional[AdditionalVolumeOption] = Field(None, description="Configuration specific to volume mounts.")
    tmpfs: Optional[Tmpfs] = Field(None, description="Configuration specific to tmpfs mounts.")
    image: Optional[Image] = Field(None, description="Configuration specific to image mounts.")


class Device(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    capabilities: ListOfStrings = Field(
        ...,
        description="List of capabilities the device needs to have (e.g., 'gpu', 'compute', 'utility').",
    )
    count: Optional[Union[str, int]] = Field(None, description="Number of devices of this type to reserve.")
    device_ids: Optional[ListOfStrings] = Field(None, description="List of specific device IDs to reserve.")
    driver: Optional[str] = Field(None, description="Device driver to use (e.g., 'nvidia').")
    options: Optional[ListOrDict] = Field(None, description="Driver-specific options for the device.")


class DevicesModel(RootModel[List[Device]]):
    root: List[Device] = Field(
        ...,
        description="Device reservations for containers, allowing services to access specific hardware devices.",
    )


class Gpu(BaseModel):
    capabilities: Optional[ListOfStrings] = Field(
        None,
        description="List of capabilities the GPU needs to have (e.g., 'compute', 'utility').",
    )
    count: Optional[Union[str, int]] = Field(None, description="Number of GPUs to use.")
    device_ids: Optional[ListOfStrings] = Field(None, description="List of specific GPU device IDs to use.")
    driver: Optional[str] = Field(None, description="GPU driver to use (e.g., 'nvidia').")
    options: Optional[ListOrDict] = Field(None, description="Driver-specific options for the GPU.")


class Gpus(RootModel[Union[Gpus1, List[Gpu]]]):
    root: Union[Gpus1, List[Gpu]]


class Network(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Optional[str] = Field(None, description="Custom name for this network.")
    driver: Optional[str] = Field(
        None,
        description="Specify which driver should be used for this network. Default is 'bridge'.",
    )
    driver_opts: Optional[Dict[str, Union[str, float]]] = Field(None, description="Specify driver-specific options defined as key/value pairs.")
    ipam: Optional[Ipam] = Field(None, description="Custom IP Address Management configuration for this network.")
    external: Optional[Union[bool, ExternalVolumeNetwork]] = Field(
        None,
        description="Specifies that this network already exists and was created outside of Compose.",
    )
    internal: Optional[Union[bool, str]] = Field(None, description="Create an externally isolated network.")
    enable_ipv4: Optional[Union[bool, str]] = Field(None, description="Enable IPv4 networking.")
    enable_ipv6: Optional[Union[bool, str]] = Field(None, description="Enable IPv6 networking.")
    attachable: Optional[Union[bool, str]] = Field(None, description="If true, standalone containers can attach to this network.")
    labels: Optional[ListOrDict] = Field(None, description="Add metadata to the network using labels.")


class Volume(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Optional[str] = Field(None, description="Custom name for this volume.")
    driver: Optional[str] = Field(None, description="Specify which volume driver should be used for this volume.")
    driver_opts: Optional[Dict[str, Union[str, float]]] = Field(None, description="Specify driver-specific options.")
    external: Optional[External1] = Field(
        None,
        description="Specifies that this volume already exists and was created outside of Compose.",
    )
    labels: Optional[ListOrDict] = Field(None, description="Add metadata to the volume using labels.")


class Secret(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Optional[str] = Field(None, description="Custom name for this secret.")
    environment: Optional[str] = Field(
        None,
        description="Name of an environment variable from which to get the secret value.",
    )
    file: Optional[str] = Field(None, description="Path to a file containing the secret value.")
    external: Optional[Union[bool, ExternalConfig]] = Field(
        None,
        description="Specifies that this secret already exists and was created outside of Compose.",
    )
    labels: Optional[ListOrDict] = Field(None, description="Add metadata to the secret using labels.")
    driver: Optional[str] = Field(None, description="Specify which secret driver should be used for this secret.")
    driver_opts: Optional[Dict[str, Union[str, float]]] = Field(None, description="Specify driver-specific options.")
    template_driver: Optional[str] = Field(None, description="Driver to use for templating the secret's value.")


class Config(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Optional[str] = Field(None, description="Custom name for this config.")
    content: Optional[str] = Field(None, description="Inline content of the config.")
    environment: Optional[str] = Field(
        None,
        description="Name of an environment variable from which to get the config value.",
    )
    file: Optional[str] = Field(None, description="Path to a file containing the config value.")
    external: Optional[External3] = Field(
        None,
        description="Specifies that this config already exists and was created outside of Compose.",
    )
    labels: Optional[ListOrDict] = Field(None, description="Add metadata to the config using labels.")
    template_driver: Optional[str] = Field(None, description="Driver to use for templating the config's value.")


class ServiceHook(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    command: Command = Field(..., description="Command to execute as part of the hook.")
    user: Optional[str] = Field(None, description="User to run the command as.")
    privileged: Optional[Union[bool, str]] = Field(None, description="Whether to run the command with extended privileges.")
    working_dir: Optional[str] = Field(None, description="Working directory for the command.")
    environment: Optional[ListOrDict] = Field(None, description="Environment variables for the command.")


class StringOrList(RootModel[Union[str, ListOfStrings]]):
    root: Union[str, ListOfStrings] = Field(..., description="Either a single string or a list of strings.")


class WatchItem(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    ignore: Optional[StringOrList] = Field(None, description="Patterns to exclude from watching.")
    include: Optional[StringOrList] = Field(None, description="Patterns to include in watching.")
    path: str = Field(..., description="Path to watch for changes.")
    action: Action = Field(
        ...,
        description="Action to take when a change is detected: rebuild the container, sync files, restart the container, sync and restart, or sync and execute a command.",
    )
    target: Optional[str] = Field(None, description="Target path in the container for sync operations.")
    exec: Optional[ServiceHook] = Field(
        None,
        description="Command to execute when a change is detected and action is sync+exec.",
    )


class Development(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    watch: Optional[List[WatchItem]] = Field(
        None,
        description="Configure watch mode for the service, which monitors file changes and performs actions in response.",
    )


class Reservations(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    cpus: Optional[Union[float, str]] = Field(
        None,
        description="Reservation for how much of the available CPU resources, as number of cores, a container can use.",
    )
    memory: Optional[str] = Field(
        None,
        description="Reservation on the amount of memory a container can allocate (e.g., '1g', '1024m').",
    )
    generic_resources: Optional[GenericResources] = Field(None, description="User-defined resources to reserve.")
    devices: Optional[DevicesModel] = Field(None, description="Device reservations for the container.")


class Resources(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    limits: Optional[Limits] = Field(None, description="Resource limits for the service containers.")
    reservations: Optional[Reservations] = Field(None, description="Resource reservations for the service containers.")


class Deployment(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    mode: Optional[str] = Field(
        None,
        description="Deployment mode for the service: 'replicated' (default) or 'global'.",
    )
    endpoint_mode: Optional[str] = Field(None, description="Endpoint mode for the service: 'vip' (default) or 'dnsrr'.")
    replicas: Optional[Union[int, str]] = Field(None, description="Number of replicas of the service container to run.")
    labels: Optional[ListOrDict] = Field(None, description="Labels to apply to the service.")
    rollback_config: Optional[RollbackConfig] = Field(None, description="Configuration for rolling back a service update.")
    update_config: Optional[UpdateConfig] = Field(None, description="Configuration for updating a service.")
    resources: Optional[Resources] = Field(None, description="Resource constraints and reservations for the service.")
    restart_policy: Optional[RestartPolicy] = Field(None, description="Restart policy for the service containers.")
    placement: Optional[Placement] = Field(
        None,
        description="Constraints and preferences for the platform to select a physical node to run service containers",
    )


class Include1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    path: Optional[StringOrList] = Field(
        None,
        description="Path to the Compose application or sub-project files to include.",
    )
    env_file: Optional[StringOrList] = Field(
        None,
        description="Path to the environment files to use to define default values when interpolating variables in the Compose files being parsed.",
    )
    project_directory: Optional[str] = Field(None, description="Path to resolve relative paths set in the Compose file")


class Include(RootModel[Union[str, Include1]]):
    root: Union[str, Include1] = Field(..., description="Compose application or sub-projects to be included.")


class Service(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    develop: Optional[Development] = None
    deploy: Optional[Deployment] = None
    annotations: Optional[ListOrDict] = None
    attach: Optional[Union[bool, str]] = None
    build: Optional[Union[str, Build]] = Field(None, description="Configuration options for building the service's image.")
    blkio_config: Optional[BlkioConfig] = Field(None, description="Block IO configuration for the service.")
    cap_add: Optional[List[str]] = Field(
        None,
        description="Add Linux capabilities. For example, 'CAP_SYS_ADMIN', 'SYS_ADMIN', or 'NET_ADMIN'.",
    )
    cap_drop: Optional[List[str]] = Field(
        None,
        description="Drop Linux capabilities. For example, 'CAP_SYS_ADMIN', 'SYS_ADMIN', or 'NET_ADMIN'.",
    )
    cgroup: Optional[Cgroup] = Field(
        None,
        description="Specify the cgroup namespace to join. Use 'host' to use the host's cgroup namespace, or 'private' to use a private cgroup namespace.",
    )
    cgroup_parent: Optional[str] = Field(None, description="Specify an optional parent cgroup for the container.")
    command: Optional[Command] = Field(
        None,
        description="Override the default command declared by the container image, for example 'CMD' in Dockerfile.",
    )
    configs: Optional[ServiceConfigOrSecret] = Field(None, description="Grant access to Configs on a per-service basis.")
    container_name: Optional[str] = Field(
        None,
        description="Specify a custom container name, rather than a generated default name.",
        pattern="[a-zA-Z0-9][a-zA-Z0-9_.-]+",
    )
    cpu_count: Optional[Union[str, CpuCount]] = Field(None, description="Number of usable CPUs.")
    cpu_percent: Optional[Union[str, CpuPercent]] = Field(None, description="Percentage of CPU resources to use.")
    cpu_shares: Optional[Union[float, str]] = Field(None, description="CPU shares (relative weight) for the container.")
    cpu_quota: Optional[Union[float, str]] = Field(None, description="Limit the CPU CFS (Completely Fair Scheduler) quota.")
    cpu_period: Optional[Union[float, str]] = Field(None, description="Limit the CPU CFS (Completely Fair Scheduler) period.")
    cpu_rt_period: Optional[Union[float, str]] = Field(
        None,
        description="Limit the CPU real-time period in microseconds or a duration.",
    )
    cpu_rt_runtime: Optional[Union[float, str]] = Field(
        None,
        description="Limit the CPU real-time runtime in microseconds or a duration.",
    )
    cpus: Optional[Union[float, str]] = Field(
        None,
        description="Number of CPUs to use. A floating-point value is supported to request partial CPUs.",
    )
    cpuset: Optional[str] = Field(None, description="CPUs in which to allow execution (0-3, 0,1).")
    credential_spec: Optional[CredentialSpec] = Field(None, description="Configure the credential spec for managed service account.")
    depends_on: Optional[Union[ListOfStrings, Dict[str, DependsOn]]] = Field(
        None,
        description="Express dependency between services. Service dependencies cause services to be started in dependency order. The dependent service will wait for the dependency to be ready before starting.",
    )
    device_cgroup_rules: Optional[ListOfStrings] = Field(None, description="Add rules to the cgroup allowed devices list.")
    devices: Optional[List[Union[str, Devices]]] = Field(None, description="List of device mappings for the container.")
    dns: Optional[StringOrList] = Field(None, description="Custom DNS servers to set for the service container.")
    dns_opt: Optional[List[str]] = Field(
        None,
        description="Custom DNS options to be passed to the container's DNS resolver.",
    )
    dns_search: Optional[StringOrList] = Field(None, description="Custom DNS search domains to set on the service container.")
    domainname: Optional[str] = Field(None, description="Custom domain name to use for the service container.")
    entrypoint: Optional[Command] = Field(
        None,
        description="Override the default entrypoint declared by the container image, for example 'ENTRYPOINT' in Dockerfile.",
    )
    env_file: Optional[EnvFile] = Field(
        None,
        description="Add environment variables from a file or multiple files. Can be a single file path or a list of file paths.",
    )
    label_file: Optional[LabelFile] = Field(
        None,
        description="Add metadata to containers using files containing Docker labels.",
    )
    environment: Optional[ListOrDict] = Field(
        None,
        description="Add environment variables. You can use either an array or a list of KEY=VAL pairs.",
    )
    expose: Optional[List[Union[str, float]]] = Field(
        None,
        description="Expose ports without publishing them to the host machine - they'll only be accessible to linked services.",
    )
    extends: Optional[Union[str, Extends]] = Field(None, description="Extend another service, in the current file or another file.")
    provider: Optional[Provider] = Field(
        None,
        description="Specify a service which will not be manage by Compose directly, and delegate its management to an external provider.",
    )
    external_links: Optional[List[str]] = Field(
        None,
        description="Link to services started outside this Compose application. Specify services as <service_name>:<alias>.",
    )
    extra_hosts: Optional[ExtraHosts] = Field(
        None,
        description="Add hostname mappings to the container network interface configuration.",
    )
    gpus: Optional[Gpus] = Field(
        None,
        description="Define GPU devices to use. Can be set to 'all' to use all GPUs, or a list of specific GPU devices.",
    )
    group_add: Optional[List[Union[str, float]]] = Field(
        None,
        description="Add additional groups which user inside the container should be member of.",
    )
    healthcheck: Optional[Healthcheck] = Field(
        None,
        description="Configure a health check for the container to monitor its health status.",
    )
    hostname: Optional[str] = Field(None, description="Define a custom hostname for the service container.")
    image: Optional[str] = Field(
        None,
        description="Specify the image to start the container from. Can be a repository/tag, a digest, or a local image ID.",
    )
    init: Optional[Union[bool, str]] = Field(
        None,
        description="Run as an init process inside the container that forwards signals and reaps processes.",
    )
    ipc: Optional[str] = Field(
        None,
        description="IPC sharing mode for the service container. Use 'host' to share the host's IPC namespace, 'service:[service_name]' to share with another service, or 'shareable' to allow other services to share this service's IPC namespace.",
    )
    isolation: Optional[str] = Field(
        None,
        description="Container isolation technology to use. Supported values are platform-specific.",
    )
    labels: Optional[ListOrDict] = Field(
        None,
        description="Add metadata to containers using Docker labels. You can use either an array or a list.",
    )
    links: Optional[List[str]] = Field(
        None,
        description="Link to containers in another service. Either specify both the service name and a link alias (SERVICE:ALIAS), or just the service name.",
    )
    logging: Optional[Logging] = Field(None, description="Logging configuration for the service.")
    mac_address: Optional[str] = Field(None, description="Container MAC address to set.")
    mem_limit: Optional[Union[float, str]] = Field(
        None,
        description="Memory limit for the container. A string value can use suffix like '2g' for 2 gigabytes.",
    )
    mem_reservation: Optional[Union[str, int]] = Field(None, description="Memory reservation for the container.")
    mem_swappiness: Optional[Union[int, str]] = Field(None, description="Container memory swappiness as percentage (0 to 100).")
    memswap_limit: Optional[Union[float, str]] = Field(
        None,
        description="Amount of memory the container is allowed to swap to disk. Set to -1 to enable unlimited swap.",
    )
    network_mode: Optional[str] = Field(
        None,
        description="Network mode. Values can be 'bridge', 'host', 'none', 'service:[service name]', or 'container:[container name]'.",
    )
    models: Optional[Union[ListOfStrings, Dict[str, Models]]] = Field(
        None,
        description="AI Models to use, referencing entries under the top-level models key.",
    )
    networks: Optional[Union[ListOfStrings, Dict[str, Optional[Networks]]]] = Field(
        None,
        description="Networks to join, referencing entries under the top-level networks key. Can be a list of network names or a mapping of network name to network configuration.",
    )
    oom_kill_disable: Optional[Union[bool, str]] = Field(None, description="Disable OOM Killer for the container.")
    oom_score_adj: Optional[Union[str, OomScoreAdj]] = Field(
        None,
        description="Tune host's OOM preferences for the container (accepts -1000 to 1000).",
    )
    pid: Optional[str] = Field(None, description="PID mode for container.")
    pids_limit: Optional[Union[float, str]] = Field(None, description="Tune a container's PIDs limit. Set to -1 for unlimited PIDs.")
    platform: Optional[str] = Field(
        None,
        description="Target platform to run on, e.g., 'linux/amd64', 'linux/arm64', or 'windows/amd64'.",
    )
    ports: Optional[List[Union[float, str, Ports]]] = Field(
        None,
        description="Expose container ports. Short format ([HOST:]CONTAINER[/PROTOCOL]).",
    )
    post_start: Optional[List[ServiceHook]] = Field(
        None,
        description="Commands to run after the container starts. If any command fails, the container stops.",
    )
    pre_stop: Optional[List[ServiceHook]] = Field(
        None,
        description="Commands to run before the container stops. If any command fails, the container stop is aborted.",
    )
    privileged: Optional[Union[bool, str]] = Field(None, description="Give extended privileges to the service container.")
    profiles: Optional[ListOfStrings] = Field(
        None,
        description="List of profiles for this service. When profiles are specified, services are only started when the profile is activated.",
    )
    pull_policy: Optional[str] = Field(
        None,
        description="Policy for pulling images. Options include: 'always', 'never', 'if_not_present', 'missing', 'build', or time-based refresh policies.",
        pattern="always|never|build|if_not_present|missing|refresh|daily|weekly|every_([0-9]+[wdhms])+",
    )
    pull_refresh_after: Optional[str] = Field(
        None,
        description="Time after which to refresh the image. Used with pull_policy=refresh.",
    )
    read_only: Optional[Union[bool, str]] = Field(None, description="Mount the container's filesystem as read only.")
    restart: Optional[str] = Field(
        None,
        description="Restart policy for the service container. Options include: 'no', 'always', 'on-failure', and 'unless-stopped'.",
    )
    runtime: Optional[str] = Field(None, description="Runtime to use for this container, e.g., 'runc'.")
    scale: Optional[Union[int, str]] = Field(None, description="Number of containers to deploy for this service.")
    security_opt: Optional[List[str]] = Field(None, description="Override the default labeling scheme for each container.")
    shm_size: Optional[Union[float, str]] = Field(
        None,
        description="Size of /dev/shm. A string value can use suffix like '2g' for 2 gigabytes.",
    )
    secrets: Optional[ServiceConfigOrSecret] = Field(None, description="Grant access to Secrets on a per-service basis.")
    sysctls: Optional[ListOrDict] = Field(
        None,
        description="Kernel parameters to set in the container. You can use either an array or a list.",
    )
    stdin_open: Optional[Union[bool, str]] = Field(None, description="Keep STDIN open even if not attached.")
    stop_grace_period: Optional[str] = Field(
        None,
        description="Time to wait for the container to stop gracefully before sending SIGKILL (e.g., '1s', '1m30s').",
    )
    stop_signal: Optional[str] = Field(None, description="Signal to stop the container (e.g., 'SIGTERM', 'SIGINT').")
    storage_opt: Optional[Dict[str, Any]] = Field(None, description="Storage driver options for the container.")
    tmpfs: Optional[StringOrList] = Field(
        None,
        description="Mount a temporary filesystem (tmpfs) into the container. Can be a single value or a list.",
    )
    tty: Optional[Union[bool, str]] = Field(None, description="Allocate a pseudo-TTY to service container.")
    ulimits: Optional[Ulimits] = Field(None, description="Override the default ulimits for a container.")
    use_api_socket: Optional[bool] = Field(None, description="Bind mount Docker API socket and required auth.")
    user: Optional[str] = Field(None, description="Username or UID to run the container process as.")
    uts: Optional[str] = Field(
        None,
        description="UTS namespace to use. 'host' shares the host's UTS namespace.",
    )
    userns_mode: Optional[str] = Field(
        None,
        description="User namespace to use. 'host' shares the host's user namespace.",
    )
    volumes: Optional[List[Union[str, Volumes]]] = Field(
        None,
        description="Mount host paths or named volumes accessible to the container. Short syntax (VOLUME:CONTAINER_PATH[:MODE])",
    )
    volumes_from: Optional[List[str]] = Field(
        None,
        description="Mount volumes from another service or container. Optionally specify read-only access (ro) or read-write (rw).",
    )
    working_dir: Optional[str] = Field(
        None,
        description="The working directory in which the entrypoint or command will be run",
    )


class ComposeSpecification(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    version: Optional[str] = Field(
        None,
        description="declared for backward compatibility, ignored. Please remove it.",
    )
    name: Optional[str] = Field(
        None,
        description="define the Compose project name, until user defines one explicitly.",
    )
    include: Optional[List[Include]] = Field(None, description="compose sub-projects to be included.")
    services: Optional[Dict[str, Service]] = Field(None, description="The services that will be used by your application.")
    models: Optional[Dict[str, Model]] = Field(None, description="Language models that will be used by your application.")
    networks: Optional[Dict[str, Optional[Network]]] = Field(None, description="Networks that are shared among multiple services.")
    volumes: Optional[Dict[str, Optional[Volume]]] = Field(None, description="Named volumes that are shared among multiple services.")
    secrets: Optional[Dict[str, Secret]] = Field(None, description="Secrets that are shared among multiple services.")
    configs: Optional[Dict[str, Config]] = Field(None, description="Configurations that are shared among multiple services.")
